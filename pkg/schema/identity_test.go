package schema

import (
	"reflect"
	"testing"
)

// TestIdentityColumnParsing tests parsing of identity column tags
func TestIdentityColumnParsing(t *testing.T) {
	// Test struct with identity columns
	type TestModel struct {
		ID1 int `po:"id1,primaryKey,bigint,identity"`        // GENERATED ALWAYS
		ID2 int `po:"id2,primaryKey,integer,identityAlways"` // GENERATED ALWAYS
		ID3 int `po:"id3,unique,bigint,identityByDefault"`   // GENERATED BY DEFAULT
		Ref int `po:"ref,integer,serial"`                    // Legacy serial (for comparison)
	}

	parser := NewParser()
	table, err := parser.Parse(reflect.TypeFor[TestModel]())
	if err != nil {
		t.Fatalf("Failed to parse model: %v", err)
	}

	// Test ID1 - identity tag (should be ALWAYS)
	id1 := table.GetColumnByName("id1")
	if id1 == nil {
		t.Fatal("Column id1 not found")
	}
	if id1.Identity == nil {
		t.Error("id1 should have Identity set")
	} else if id1.Identity.Generation != IdentityAlways {
		t.Errorf("id1 should be GENERATED ALWAYS, got %s", id1.Identity.Generation)
	}

	// Test ID2 - identityAlways tag
	id2 := table.GetColumnByName("id2")
	if id2 == nil {
		t.Fatal("Column id2 not found")
	}
	if id2.Identity == nil {
		t.Error("id2 should have Identity set")
	} else if id2.Identity.Generation != IdentityAlways {
		t.Errorf("id2 should be GENERATED ALWAYS, got %s", id2.Identity.Generation)
	}

	// Test ID3 - identityByDefault tag
	id3 := table.GetColumnByName("id3")
	if id3 == nil {
		t.Fatal("Column id3 not found")
	}
	if id3.Identity == nil {
		t.Error("id3 should have Identity set")
	} else if id3.Identity.Generation != IdentityByDefault {
		t.Errorf("id3 should be GENERATED BY DEFAULT, got %s", id3.Identity.Generation)
	}

	// Test ref - serial (should NOT have Identity)
	ref := table.GetColumnByName("ref")
	if ref == nil {
		t.Fatal("Column ref not found")
	}
	if ref.Identity != nil {
		t.Error("ref (serial) should NOT have Identity set")
	}
	if !ref.AutoIncrement {
		t.Error("ref (serial) should have AutoIncrement set")
	}

	t.Logf("✅ All identity column tags parsed correctly")
}

// TestIdentityAndSerialMutualExclusive tests that identity and serial are handled correctly
func TestIdentityAndSerialMutualExclusive(t *testing.T) {
	type TestModel struct {
		ID int `po:"id,primaryKey,bigint,identity"`
	}

	parser := NewParser()
	table, err := parser.Parse(reflect.TypeFor[TestModel]())
	if err != nil {
		t.Fatalf("Failed to parse model: %v", err)
	}

	id := table.GetColumnByName("id")
	if id == nil {
		t.Fatal("Column id not found")
	}

	// Identity column should not have AutoIncrement set
	// (they are different mechanisms)
	if id.Identity != nil && id.AutoIncrement {
		t.Error("Column should use either Identity OR AutoIncrement, not both")
	}

	if id.Identity == nil {
		t.Error("Column should have Identity set")
	}

	t.Logf("✅ Identity column correctly uses Identity, not AutoIncrement")
}

// TestIdentityColumnTypes tests different column types with identity
func TestIdentityColumnTypes(t *testing.T) {
	type TestModel struct {
		SmallID int16 `po:"small_id,smallint,identity"`
		IntID   int   `po:"int_id,integer,identityByDefault"`
		BigID   int64 `po:"big_id,bigint,identity"`
	}

	parser := NewParser()
	table, err := parser.Parse(reflect.TypeFor[TestModel]())
	if err != nil {
		t.Fatalf("Failed to parse model: %v", err)
	}

	testCases := []struct {
		name      string
		colName   string
		expectGen IdentityGeneration
	}{
		{"smallint", "small_id", IdentityAlways},
		{"integer", "int_id", IdentityByDefault},
		{"bigint", "big_id", IdentityAlways},
	}

	for _, tc := range testCases {
		t.Run(tc.name, func(t *testing.T) {
			col := table.GetColumnByName(tc.colName)
			if col == nil {
				t.Fatalf("Column %s not found", tc.colName)
			}
			if col.Identity == nil {
				t.Errorf("Column %s should have Identity set", tc.colName)
			} else if col.Identity.Generation != tc.expectGen {
				t.Errorf("Column %s should be %s, got %s",
					tc.colName, tc.expectGen, col.Identity.Generation)
			}
		})
	}
}
