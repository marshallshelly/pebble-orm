package migration

import (
	"testing"

	"github.com/marshallshelly/pebble-orm/pkg/schema"
)

// TestIdentityColumnGeneration tests identity column SQL generation
func TestIdentityColumnGeneration(t *testing.T) {
	planner := NewPlanner()

	testCases := []struct {
		name        string
		column      schema.ColumnMetadata
		expectedSQL string
	}{
		{
			name: "GENERATED ALWAYS AS IDENTITY",
			column: schema.ColumnMetadata{
				Name:    "id",
				SQLType: "bigint",
				Identity: &schema.IdentityColumn{
					Generation: schema.IdentityAlways,
				},
			},
			expectedSQL: "id bigint GENERATED ALWAYS AS IDENTITY",
		},
		{
			name: "GENERATED BY DEFAULT AS IDENTITY",
			column: schema.ColumnMetadata{
				Name:    "id",
				SQLType: "integer",
				Identity: &schema.IdentityColumn{
					Generation: schema.IdentityByDefault,
				},
			},
			expectedSQL: "id integer GENERATED BY DEFAULT AS IDENTITY",
		},
		{
			name: "bigint identity always",
			column: schema.ColumnMetadata{
				Name:    "user_id",
				SQLType: "bigint",
				Identity: &schema.IdentityColumn{
					Generation: schema.IdentityAlways,
				},
			},
			expectedSQL: "user_id bigint GENERATED ALWAYS AS IDENTITY",
		},
	}

	for _, tc := range testCases {
		t.Run(tc.name, func(t *testing.T) {
			sql := planner.generateColumnDefinition(tc.column)
			if sql != tc.expectedSQL {
				t.Errorf("Expected: %s\nGot: %s", tc.expectedSQL, sql)
			}
		})
	}
}

// TestIdentityColumnInCreateTable tests full CREATE TABLE with identity column
func TestIdentityColumnInCreateTable(t *testing.T) {
	planner := NewPlanner()

	table := &schema.TableMetadata{
		Name: "users",
		Columns: []schema.ColumnMetadata{
			{
				Name:    "id",
				SQLType: "bigint",
				Identity: &schema.IdentityColumn{
					Generation: schema.IdentityAlways,
				},
			},
			{
				Name:     "email",
				SQLType:  "varchar(255)",
				Nullable: false,
				Unique:   true,
			},
			{
				Name:     "name",
				SQLType:  "text",
				Nullable: false,
			},
		},
		PrimaryKey: &schema.PrimaryKeyMetadata{
			Name:    "users_pkey",
			Columns: []string{"id"},
		},
	}

	sql := planner.generateCreateTable(table)

	// Check that it contains the identity column definition
	if !contains(sql, "id bigint GENERATED ALWAYS AS IDENTITY") {
		t.Errorf("Expected CREATE TABLE to contain identity column definition\nGot: %s", sql)
	}

	// Check that it contains primary key
	if !contains(sql, "CONSTRAINT users_pkey PRIMARY KEY (id)") {
		t.Errorf("Expected CREATE TABLE to contain primary key\nGot: %s", sql)
	}

	t.Logf("Generated SQL:\n%s", sql)
}

// TestIdentityByDefaultColumn tests BY DEFAULT variant
func TestIdentityByDefaultColumn(t *testing.T) {
	planner := NewPlanner()

	table := &schema.TableMetadata{
		Name: "orders",
		Columns: []schema.ColumnMetadata{
			{
				Name:    "id",
				SQLType: "integer",
				Identity: &schema.IdentityColumn{
					Generation: schema.IdentityByDefault,
				},
			},
			{
				Name:     "order_number",
				SQLType:  "varchar(50)",
				Nullable: false,
			},
		},
		PrimaryKey: &schema.PrimaryKeyMetadata{
			Name:    "orders_pkey",
			Columns: []string{"id"},
		},
	}

	sql := planner.generateCreateTable(table)

	if !contains(sql, "id integer GENERATED BY DEFAULT AS IDENTITY") {
		t.Errorf("Expected CREATE TABLE to contain BY DEFAULT identity column\nGot: %s", sql)
	}

	t.Logf("Generated SQL:\n%s", sql)
}

// TestIdentityVsSerial compares identity and serial columns
func TestIdentityVsSerial(t *testing.T) {
	planner := NewPlanner()

	identityCol := schema.ColumnMetadata{
		Name:    "id",
		SQLType: "integer",
		Identity: &schema.IdentityColumn{
			Generation: schema.IdentityAlways,
		},
	}

	serialCol := schema.ColumnMetadata{
		Name:          "id",
		SQLType:       "serial",
		AutoIncrement: true,
	}

	identitySQL := planner.generateColumnDefinition(identityCol)
	serialSQL := planner.generateColumnDefinition(serialCol)

	t.Logf("Identity SQL: %s", identitySQL)
	t.Logf("Serial SQL: %s", serialSQL)

	// They should be different
	if identitySQL == serialSQL {
		t.Errorf("Identity and serial columns should generate different SQL")
	}

	// Identity should have GENERATED AS IDENTITY
	if !contains(identitySQL, "GENERATED ALWAYS AS IDENTITY") {
		t.Errorf("Identity column should contain GENERATED ALWAYS AS IDENTITY")
	}

	// Serial should be simpler
	if contains(serialSQL, "GENERATED") {
		t.Errorf("Serial column should not contain GENERATED keyword")
	}
}
